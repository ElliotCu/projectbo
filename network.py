# -*- coding: Utf-8 -*
# Author: aurelien.esnard@u-bordeaux.fr

from model import *
import socket
import select
import pickle

#importation useful for viewig map
#dont delete the following section
from view import *
from keyboard import *
import sys
import pygame
################################################################################
#                          NETWORK SERVER CONTROLLER                           #
################################################################################

class NetworkServerController:

    def __init__(self, model, port):
        self.model = model
        self.port = port
        #initialize the socket connection
        self.s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, 0)
        print ("Socket created")
        self.s.setblocking(False)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind(('',port))
        print ("Socket binded")
        self.s.listen(5)
        #Empty client list
        self.client = []
        
        

    def send_map(self, conn):
        send_map = pickle.dumps(self.model.map)
        conn.sendall(send_map)
        ack = conn.recv(1024)


    def send_fruits(self, conn):
        send_fruits = pickle.dumps(self.model.fruits)
        conn.sendall(send_fruits)
        ack = conn.recv(1024)

    def receive_player(self, conn):
        new_player = conn.recv(4096)
        map_player = pickle.loads(new_player)
        conn.send(b"ACK")                       #ack to confirm receiving player
        self.model.player = map_player
        if map_player  not in self.model.characters :
            self.model.characters.append(map_player)
        
            
    def send_characters(self, conn):
        send_character = pickle.dumps(self.model.characters)
        conn.sendall(send_character)
        ack = conn.recv(1024)

    def send_bomb(self, conn):
        send_bomb = pickle.dumps(self.model.bombs)
        conn.sendall(send_bomb)
        ack = conn.recv(1024)

    def send_initialised_model(self, conn):
        self.send_map(conn)   #this function load the map and send it to the client
        print("map was send successfully")
        self.send_fruits(conn)
        print("Fruits were sent successfully")
        self.receive_player(conn)
        print("player is received successfully")
        self.send_characters(conn)
        print("Characters were sent successfully")
        self.send_bomb(conn)
        print("Bombs were sent successfully")
        
    # time event        
    def tick(self, dt):
        (ready_to_read,_,_) = select.select(self.client+[self.s], [], [])
        for sock in ready_to_read:
            if sock == self.s and ready_to_read:
                conn, addr = self.s.accept()
                print("{} connected".format(addr))
                view = GraphicView(self.model, "network map") #dont delete this line 
                #part 1 : sending model to work with 
                self.send_initialised_model(conn)
                print("initialised map sent successfully")
                #part 2 : receiving events and modifying the model
                '''code'''
                #part 3 : view the model on the serveur for verification purposes
                view.tick(dt) #dont delete this line
                print("netwok map printed")
        return True

################################################################################
#                          NETWORK CLIENT CONTROLLER                           #
################################################################################

class NetworkClientController:

    def __init__(self, model, host, port, nickname):
        self.model = model
        self.host = host
        self.port = port
        self.nickname = nickname
        #connecting to the game server
        self.sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, 0)
        self.sock.connect((host, port))
        print("Connected to the game server")
        print("Host: {} Port: {}".format(self.host, self.port))

        #receive the map
        the_map = self.sock.recv(4096)  #receiving the correct map
        map_complete = pickle.loads(the_map)
        print("map well received!")
        self.sock.send(b"ACK")          #ack confrimation 
        self.model.map = map_complete            #Load the map
        

        #receiving fruits
        fruits = self.sock.recv(4096)
        map_fruits = pickle.loads(fruits)
        self.sock.send(b"ACK")          #ack to confirm receiving fruits
        self.model.fruits = map_fruits   #load fruits generated by server
        print("fruits well received!")

        #send player
        send_player = self.model.add_character(nickname, isplayer = True)
        send_pl = pickle.dumps(send_player)
        self.sock.sendall(send_pl)
        ack = self.sock.recv(1024)
        print("player well sent!")

        #receiving characters
        characters = self.sock.recv(4096)
        map_characters = pickle.loads(characters)
        self.sock.send(b"ACK")                   #ack to confirm receiving characters
        self.model.characters = map_characters   #load characters generated by server
        print("Characters well received!")

        #receive bombs
        bombs = self.sock.recv(4096)
        map_bombs = pickle.loads(bombs)
        self.sock.send(b"ACK")
        self.model.bombs = map_bombs
        print("Bombs well received!")
    
    # keyboard events

    def keyboard_quit(self):
        print("=> event \"quit\"")
        return False

    def keyboard_move_character(self, direction): #Floki:I completed this function from bomber.py
        print("=> event \"keyboard move direction\" {}".format(DIRECTIONS_STR[direction]))
        if not self.model.player: return True
        nickname = self.model.player.nickname
        if direction in DIRECTIONS:
            self.model.move_character(nickname, direction)
        # ...
        return True

    def keyboard_drop_bomb(self):               #Floki:I completed this function from bomber.py
        print("=> event \"keyboard drop bomb\"")
        if not self.model.player: return True
        nickname = self.model.player.nickname
        self.model.drop_bomb(nickname)
        # ...
        return True


    
    # time event

    def tick(self, dt):
        return True
